# Publishing Custom Gradle Plugin explained step by step

kazurayam,
26 March 2023

## Introduction

In this article I will explain how to publish custom Gradle plugins. I will present working sample codes. I will explain what sort of artifacts (files) are generated in the `<projectDir>/build` directory by the `java-gradle-plugin` and the `maven-publish` plugin.

I have made a public GitHub repository of this article and sample codes

-   <https://github.com/kazurayam/PublishingCustomGradlePlugin_StepByStep>

I used the gradle version 8.0.2, Java 17.0.7, macOS 12.6

## §1 Start up

### What I’m doing here

In the step1, I will create a skeletal project where I will write a Groovy code as a custom Gradle plugin.

### settings.gradle and build.gradle

I made a directory named `step1` where I located `step1/settings.gradle` and `step1/build.gradle`.

#### step1/settings.gradle

    rootProject.name = 'step1'

#### step1/build.gradle

    plugins {
        id 'groovy'
    }

    group = 'com.example'
    version = '1.0'

    repositories {
        mavenCentral()
    }

    dependencies {
        // Use the awesome Spock testing and specification framework
        testImplementation 'org.spockframework:spock-core:2.3-groovy-3.0'
    }

    tasks.named('test') {
        // Use JUnit Jupiter for unit tests.
        useJUnitPlatform()
    }

### code of custom Gradle plugin

I wrote `step1/src/main/groovy/com/example/greeting/GreetingPlguin`.

    package com.example.greeting

    import org.gradle.api.Plugin
    import org.gradle.api.Project

    class GreetingPlugin implements Plugin<Project> {
        void apply(Project project) {
            project.task('hello') {
                doLast {
                    println "Hello from GreetingPlugin"
                }
            }
            project.task('goodbye') {
                doLast {
                    println "Goodbye from GreetingPlugin"
                }
            }
        }
    }

### code of JUnit5 test

`step1/src/test/groovy/com/example/greeting/GreetingPluginTest.groovy`

    package com.example.greeting

    import org.gradle.api.Project
    import org.gradle.testfixtures.ProjectBuilder
    import spock.lang.Specification

    class GreetingPluginTest extends Specification {
        def "the plugin registers the tasks"() {
            given:
            Project project = ProjectBuilder.builder().build()

            when:
            project.plugins.apply("org.sample.Greetings")

            then:
            project.tasks.findByName("hello") != null
            project.tasks.findByName("goodbye") != null

        }
    }

### How the build works

I tried to compile the Groovy code, but it doesn’t compile.

![1 1.GradleApiNotAccessible](images/1_1.GradleApiNotAccessible.png)

The Gradle API is not accessible for the compiler. Therefore, Groovy compiler failed to find the very core class `org.gradle.api.Project`.

### What needs to be done

In order to compile the code, I need to introduce the [java-gradle-plugin](https://docs.gradle.org/current/userguide/java_gradle_plugin.html) into the `build.gradle`. I will try it in the step2.

## §2 java-gradle-plugin

### What I’m doing here

Based on the step1, I will introduce the [java-gradle-plugin](https://docs.gradle.org/current/userguide/java_gradle_plugin.html) into the build.gradle file. With the plugin, the Gradle API becomes available to the `compileGroovy` task.

### settings.gradle and build.gradle

I made a directory named `step1` where I located `step1/settings.gradle` and `step1/build.gradle`.

#### step2/settings.gradle

    rootProject.name = 'step2'

#### step2/build.gradle

Refer to [step2/build.gradle](https://github.com/kazurayam/PublishingCustomGradlePlugin_StepByStep/blob/develop/step2/build.gradle)

Please note the 3rd line, we declare we use the java-gradle-plugin:

        id 'java-gradle-plugin'

And line#24, we declare the `plugin id` and the name of the implementation class:

    gradlePlugin {
        // Define the plugin
        plugins {
            MyGreeting {
                id = 'org.sample.Greetings'
                implementationClass = 'com.example.greeting.GreetingPlugin'
            }
        }
    }

You should note that the plugin id can be totally different from the class name. In order to demonstrate this point, I intentionally named the plugin id `org.sample.Greetings` and the fully qualified class name `com.example.greeting.GreeingPlugin`.

The following Gradle document describe how you can name the plugin id:

-   [creating a plugin id](https://docs.gradle.org/current/userguide/custom_plugins.html#sec:creating_a_plugin_id)

### How the build works

I could compile the Groovy code and run the junit test.

![2.1 success compile and test](images/2.1_success_compile_and_test.png)

### Artifacts generated by java-gradle-plugin

In the `step2/build` directory, the java-gradle-plugin generated a lot of artifacts (files). Let’s look at them to see what the plugin did for us.

#### build directory

The `java-gradle-plugin` generated several artifacts in the `build` directory.

    $ tree ./build
    ./build
    ├── classes
    │   └── ...
    ├── generated
    │   └── ...
    ├── pluginDescriptors
    │   └── org.sample.Greetings.properties
    ├── pluginUnderTestMetadata
    │   └── ...
    ├── reports
    │   └── ...
    ├── resources
    │   └── main
    │       └── META-INF
    │           └── gradle-plugins
    │               └── org.sample.Greetings.properties
    ├── test-results
    │   └── ...
    └── tmp
        ├── ...

    47 directories, 20 files

Amongst them, the following files are interesting:

`step2/build/pluginDescriptors/org.sample.Greetings.properties`

    implementation-class=com.example.greeting.GreetingPlugin

`step2/build/resources/main/META-INF/gradle-plugins/org.sample.Greetings.properties`

    implementation-class=com.example.greeting.GreetingPlugin

In the Gradle documentation you can find a description what this properties file is.

-   [Behind the scene](https://docs.gradle.org/current/userguide/custom_plugins.html#behind_the_scenes)

step3 : want to publish the plugin artifact into a local Maven repository

step4 : want to publish artifacts into 2 types of repositories: Maven and Ivy

step5 : want to publish multiple custom plugins out of a single project

step6 : want to specify the name of jar file.

step7 : want to publish the sources.jar and the javadoc.jar.
